// Code generated by moq; DO NOT EDIT
// github.com/matryer/moq

package eventSourcing

import (
	"sync"
)

var (
	lockeventStoreMockload sync.RWMutex
	lockeventStoreMocksave sync.RWMutex
)

// eventStoreMock is a mock implementation of eventStore.
//
//     func TestSomethingThatUseseventStore(t *testing.T) {
//
//         // make and configure a mocked eventStore
//         mockedeventStore := &eventStoreMock{
//             loadFunc: func(ID string) (*domainMessages, error) {
// 	               panic("TODO: mock out the load method")
//             },
//             saveFunc: func(message *domainMessage) error {
// 	               panic("TODO: mock out the save method")
//             },
//         }
//
//         // TODO: use mockedeventStore in code that requires eventStore
//         //       and then make assertions.
//
//     }
type eventStoreMock struct {
	// loadFunc mocks the load method.
	loadFunc func(ID string) (*domainMessages, error)

	// saveFunc mocks the save method.
	saveFunc func(message *domainMessage) error

	// calls tracks calls to the methods.
	calls struct {
		// load holds details about calls to the load method.
		load []struct {
			// ID is the ID argument value.
			ID string
		}
		// save holds details about calls to the save method.
		save []struct {
			// Message is the message argument value.
			Message *domainMessage
		}
	}
}

// load calls loadFunc.
func (mock *eventStoreMock) load(ID string) (*domainMessages, error) {
	if mock.loadFunc == nil {
		panic("moq: eventStoreMock.loadFunc is nil but eventStore.load was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: ID,
	}
	lockeventStoreMockload.Lock()
	mock.calls.load = append(mock.calls.load, callInfo)
	lockeventStoreMockload.Unlock()
	return mock.loadFunc(ID)
}

// loadCalls gets all the calls that were made to load.
// Check the length with:
//     len(mockedeventStore.loadCalls())
func (mock *eventStoreMock) loadCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	lockeventStoreMockload.RLock()
	calls = mock.calls.load
	lockeventStoreMockload.RUnlock()
	return calls
}

// save calls saveFunc.
func (mock *eventStoreMock) save(message *domainMessage) error {
	if mock.saveFunc == nil {
		panic("moq: eventStoreMock.saveFunc is nil but eventStore.save was just called")
	}
	callInfo := struct {
		Message *domainMessage
	}{
		Message: message,
	}
	lockeventStoreMocksave.Lock()
	mock.calls.save = append(mock.calls.save, callInfo)
	lockeventStoreMocksave.Unlock()
	return mock.saveFunc(message)
}

// saveCalls gets all the calls that were made to save.
// Check the length with:
//     len(mockedeventStore.saveCalls())
func (mock *eventStoreMock) saveCalls() []struct {
	Message *domainMessage
} {
	var calls []struct {
		Message *domainMessage
	}
	lockeventStoreMocksave.RLock()
	calls = mock.calls.save
	lockeventStoreMocksave.RUnlock()
	return calls
}
