// Code generated by moq; DO NOT EDIT
// github.com/matryer/moq

package eventSourcing

import (
	"sync"
)

var (
	lockeventStoreIMockload sync.RWMutex
	lockeventStoreIMocksave sync.RWMutex
)

// eventStoreIMock is a mock implementation of eventStoreI.
//
//     func TestSomethingThatUseseventStoreI(t *testing.T) {
//
//         // make and configure a mocked eventStoreI
//         mockedeventStoreI := &eventStoreIMock{
//             loadFunc: func(ID string) ([]*domainMessage, error) {
// 	               panic("TODO: mock out the load method")
//             },
//             saveFunc: func(message *domainMessage) error {
// 	               panic("TODO: mock out the save method")
//             },
//         }
//
//         // TODO: use mockedeventStoreI in code that requires eventStoreI
//         //       and then make assertions.
//
//     }
type eventStoreIMock struct {
	// loadFunc mocks the load method.
	loadFunc func(ID string) ([]*domainMessage, error)

	// saveFunc mocks the save method.
	saveFunc func(message *domainMessage) error

	// calls tracks calls to the methods.
	calls struct {
		// load holds details about calls to the load method.
		load []struct {
			// ID is the ID argument value.
			ID string
		}
		// save holds details about calls to the save method.
		save []struct {
			// Message is the message argument value.
			Message *domainMessage
		}
	}
}

// load calls loadFunc.
func (mock *eventStoreIMock) load(ID string) ([]*domainMessage, error) {
	if mock.loadFunc == nil {
		panic("moq: eventStoreIMock.loadFunc is nil but eventStoreI.load was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: ID,
	}
	lockeventStoreIMockload.Lock()
	mock.calls.load = append(mock.calls.load, callInfo)
	lockeventStoreIMockload.Unlock()
	return mock.loadFunc(ID)
}

// loadCalls gets all the calls that were made to load.
// Check the length with:
//     len(mockedeventStoreI.loadCalls())
func (mock *eventStoreIMock) loadCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	lockeventStoreIMockload.RLock()
	calls = mock.calls.load
	lockeventStoreIMockload.RUnlock()
	return calls
}

// save calls saveFunc.
func (mock *eventStoreIMock) save(message *domainMessage) error {
	if mock.saveFunc == nil {
		panic("moq: eventStoreIMock.saveFunc is nil but eventStoreI.save was just called")
	}
	callInfo := struct {
		Message *domainMessage
	}{
		Message: message,
	}
	lockeventStoreIMocksave.Lock()
	mock.calls.save = append(mock.calls.save, callInfo)
	lockeventStoreIMocksave.Unlock()
	return mock.saveFunc(message)
}

// saveCalls gets all the calls that were made to save.
// Check the length with:
//     len(mockedeventStoreI.saveCalls())
func (mock *eventStoreIMock) saveCalls() []struct {
	Message *domainMessage
} {
	var calls []struct {
		Message *domainMessage
	}
	lockeventStoreIMocksave.RLock()
	calls = mock.calls.save
	lockeventStoreIMocksave.RUnlock()
	return calls
}
